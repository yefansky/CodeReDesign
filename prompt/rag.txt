我需要新做一个文档对话功能，选中sidebar里的cvb文件，
会先将文件读取转换成cvb内存格式
然后调用rag.ts中的LoadCVB的接口
把他进行分拆记忆
然后做一个聊天的webPanel（新生成一个 chatToDoc.ts）
每次提问，都效用rag.ts里的query
找出top5以后调用deepseekapi去总结
然后以对话形式输出
排版就很类似chatpanel了
你完整实现一下


可以用一个简化的实现来处理长文本

如果读入的CVB比较大，模型的注意力容易丢失，这是一个改进方案
1.如果当前处理的CVB超过2k大小则启用压缩机制
2.先遍历每个文件，如果文件还是太长，就切页
3.把每个页+需求一起prompt给api，告诉他从上到下按照顺序抽取有用的片段，
有用的意思是指可以用来修改替换的内容
或者是用来插入的锚点附近的上下文
以及可以用来解释需求作为辅助说明的代码
4.每个抽取块之间用 //... 来分割
5.把抽取信息重新拼成一个CVB，加上原始需求，并解释 //... 是省略上下文的提示，不可以用来当做锚点
然后走老流程读取CVB进行重构。

以上流程同样适用于分析代码
此设计的假设是实际需要用到的代码信息并不会超过大模型的最大token数
只是因为代码里包含了太多的无用信息才导致的超长

所以抽取完合并之后要再一次检查一下长度有没有超长
如果超了，可以再一次调用压缩

---------

按照以下方案制作功能：
当大模型处理超长文本（如企业级代码库）时，过大的文件体积会导致模型注意力丢失，影响处理效果。为解决这一问题，改进后的方案通过压缩和抽取关键信息，减少输入给模型的文本长度，同时确保保留对任务有用的核心代码信息。以下是方案的详细设计：

1. 压缩触发条件
触发阈值：当upload操作输入的CVB（代码表示文件）大小超过4k字符时，启动压缩机制。
缓存检查：检查本地是否存在该CVB的压缩版本CCVB（压缩后的CVB）。若存在，直接使用缓存的CCVB；若不存在，进入压缩流程生成CCVB。
2. 压缩流程
文件切页
遍历代码库中的每个文件。
若文件过长（例如超过1k token），按代码的逻辑结构（如函数、类、模块）进行切分，确保每个页面不超过2k token，并保留语义完整性。
若按逻辑结构切分失败，回退到按行切分（例如每100行一页）。
信息抽取
对每个切分后的页面，结合任务需求，构造结构化的Prompt发送给API，要求API按顺序抽取有用代码片段。
Prompt结构：
代码页面内容：当前处理的代码片段。
需求描述：明确的任务目标，例如“找到实现登录功能的代码并提取可替换的部分”。
抽取标准：
可用于修改或替换的代码。
插入锚点附近的上下文（建议保留前后5行）。
可用于解释需求的辅助代码。
输出格式：要求API返回的代码块之间用//...分隔。
抽取块处理：
每个抽取块保留少量上下文信息（例如前后5行），确保合并后的CVB语义连贯。
若API抽取失败，记录失败页面并跳至下一页。
合并与检查
将所有抽取的代码块合并为一个新的CVB，附上原始需求。
在合并的CVB中加入注释，明确//...是省略上下文的标记，不可作为插入锚点：
text
Wrap
Copy
// 注意：//... 表示省略的上下文，仅用于分隔，不可用作插入锚点
合并后检查CVB的token长度：
若仍超过模型的token限制（例如2k token），进行第二轮压缩，逐步提高压缩强度（如删除注释、精简次要函数等）。
设定压缩次数上限（例如3次），防止无限循环。
3. 重新构建CVB并进行重构
将压缩后的CCVB作为输入，结合原始需求，进行代码重构或分析。
在重构流程中，确保模型正确识别//...标记，避免将其误用为锚点。
4. 错误处理与优化
错误处理：
若文件切页失败，回退到更小的切分单位（如按行切分）。
若API返回无效或空的结果，记录失败页面并继续处理下一页。
性能优化：
并行处理多个页面，减少API调用的等待时间。
在本地缓存CCVB文件，避免对相同CVB重复压缩。
定期清理过时的CCVB缓存，节省存储空间。
5. 方案验证
测试：
在不同规模的代码库（小型、中型、企业级）上测试方案。
衡量压缩后CVB的token长度、抽取准确率、重构成功率等指标。
调优：
根据测试结果调整切页大小、Prompt设计和压缩强度，确保方案在实际应用中的有效性。

-------------
写一个cvb压缩函数 compressCvb，传入cvb和用户需求

然后遍历cvb里的逐个文件+需求上传api，让api抽取出有价值的片段
有价值的片段包括：
1.在后续重构步骤中能提供关键信息方便模型理解的
2.被重构的代码块
3.插入或者替换新代码块时需要的锚点附近的上下文

同一个文件里的多个有价值块之间用以下省略符
//...CCVB
来分割

最后把输出重新拼起来，输出格式还是cvb
只不过里面的无关代码被抽取后变成了省略符
